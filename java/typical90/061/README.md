# Main0
いつも使っているArrayDeque<Integer>で解けるかと思ったが、
内部は配列Object[] elements;なのに、これとint head;とint tail;を使って
添字int idxでアクセスする術がない。
Object[] toArray()でコピーを作るのもどうかと思ったので、
Iterator<E> iterator()で空回ししたが、TLE2個。

# Main
仕方ないので、使っているaddFirstとaddLastと欲しいgetを持つMyDequeを作る。
内部の配列を拡張するのが面倒なので、最初から200*1000の2倍のサイズを確保し、
head=tailを真ん中の100*1000にする。
addFirstが先にhead--;するので、100*1000回addFirstやaddLastしてもオーバーしないはず。

# Main_fix
new MyDeque(q)として、toString()でary,head,tailをデバッグ出力する。
t=1,2のときにデバッグ出力する。

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 6 6
[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0] 5 6
[0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0] 4 6
[0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0] 4 7

# Main_final
先頭と末尾を連結してリングバッファにする。
サイズn*2をnにしたいが、head==tailが初期値なので、
サイズをn+1確保して、tail+1==headまで追加できるようにする。
固定長配列なので、キューが一杯にならないものとする。

headとtailの初期値をコンストラクタで渡し、
headが末尾に行く場合と、tailが先頭に行く場合のデバッグ出力。

new MyDeque(q, 0);
[0, 0, 0, 0, 0, 0, 0] 0 0
[0, 0, 0, 0, 0, 0, 3] 6 0
[0, 0, 0, 0, 0, 2, 3] 5 0
[4, 0, 0, 0, 0, 2, 3] 5 1
[4, 5, 0, 0, 0, 2, 3] 5 2
[4, 5, 6, 0, 0, 2, 3] 5 3
[4, 5, 6, 0, 1, 2, 3] 4 3

new MyDeque(q, q-1);
[0, 0, 0, 0, 0, 0, 0] 5 5
[0, 0, 0, 0, 3, 0, 0] 4 5
[0, 0, 0, 2, 3, 0, 0] 3 5
[0, 0, 0, 2, 3, 4, 0] 3 6
[0, 0, 0, 2, 3, 4, 5] 3 0
[6, 0, 0, 2, 3, 4, 5] 3 1
[6, 0, 1, 2, 3, 4, 5] 2 1

MyDeque_int20250105を適用
