# Main
int[] aryに入れてソートしたが、二分検索して、以下、以上の2方向を探す手間を考えて、
NavigableSet<Integer>のceilingとfloorを使った。
左端や右端はnullが返るので、その場合は片方のみとなる。

# Main_bsearch
Arrays.binarySearch版も作ってみる。
戻り値がマイナスの場合、i=-(i+1);で0からnとして挿入ポイントを使っていたが、
l=-(l+1)-1;とさらに-1して、-1からn-1の方が使いやすい。
0<=i<nの範囲チェックし、ary[i]とary[i+1]が候補となる値。

左端、中央、右端が判定基準のため、特化したテストデータでデバッグ出力する。
デバッグ出力のskip:-1が左端の回避、skip:4が右端の回避。

4
100 200 300 400
3
90
120
430
[100, 200, 300, 400]
skip:-1
10
20
skip:4
30
