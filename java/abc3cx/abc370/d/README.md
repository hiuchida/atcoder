# Main0
ポイントから上下左右にループしているので、間に合わないと思って出して、TLE。

作りかけの手元のソースで、
x座標をキーにしたmapと、y座標をキーにしたmapを用意して、両方を更新したが、
端を高速に求めることに悩んだ。

# Main
まず勘違いしていたのが、h,w<=4\*10^5と思い込んでいて、h\*wは10^10のため
密に管理できないと。実際は、h\*w<=4\*10^5のため、壁をすべてmapx,mapyに登録して、
穴が空いた座標を取り除けば、TreeSetのhigher,lowerで、指定した座標より離れた直近の
座標が探せる。

# Main_unionFind0
壁でなく、穴を管理する方法で、遅いUnionFindで穴を連結する。TLE。

# Main_unionFind
UnionFindの親に左端と右端を持たせる。
座標を+1,-1して連結するので、穴の座標の最小値、最大値が求まる。
mergeした際に、子供になる方は本来そのままでも良いが、
デバッグ出力した際にゴミが残っているのが紛らわしいので、
lt[]とrt[]に-1を入れる。

# Main_unionFind_fix
デバッグ出力の改良。
mapをそのままtoString()すると、1行となるので、keyごとに改行する。
子供は親のidxの前に*をつける。
自分自身のみの場合は、個数=1のみ。
子供を持つ親は個数と左端、右端を表示する。

s=[(1, 2), (2, 1), (2, 2), (2, 3), (2, 4), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 2), (4, 3), (5, 2)]
X1:[1, 1, 2(2-3), *2, 1, 1, 1]
X2:[1, *3, *3, 5(1-5), *3, *3, 1]
X3:[1, 1, *3, 3(2-4), *3, 1, 1]
X4:[1, 1, 2(2-3), *2, 1, 1, 1]
X5:[1, 1, 1, 1, 1, 1, 1]
Y1:[1, 1, 1, 1, 1, 1, 1]
Y2:[1, *2, 4(1-4), *2, *2, 1, 1]
Y3:[1, *2, 5(1-5), *2, *2, *2, 1]
Y4:[1, 1, 2(2-3), *2, 1, 1, 1]
Y5:[1, 1, 1, 1, 1, 1, 1]
