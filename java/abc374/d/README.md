# Main
n=6のとき、最大12x10x8x6x4x2=46,080から総当たりで解ける見込みで、
dfsで組み合わせを網羅して、dfsのメソッド内で0と1で線の座標を左右か右左か2通りを判定した。
方針は解説通りだったが、dfsの中で変数を書き換えて子供を呼び、戻ったときにans候補を戻していなかった。
フラグとしてTreeSet<Integer>を使っていたが、デバッグするためにsetを表示すると
ソートされてしまい、呼び出し順（順列の選択したパターン）が分からず、ArrayList<Integer>に替えたので、
set.contains(i)は先頭からの逐次検索となっている。

出力例１の解説通りに計算して、浮動小数点の結果が同じになるのか、確認したが、
dfsを組む前に単体テストをしたのは効果があった。（後からlines[n].dtをクラス内でtで割っているので古いソース）
ans += lines[1].dt / t;
pt = lines[1].fm;
ans += calcmove(pt, lines[0].fm);
ans += lines[0].dt / t;
pt = lines[0].to;
ans += calcmove(pt, lines[2].to);
ans += lines[2].dt / t;

# Main_myStack
List<T> listとSet<T> setの両方を持つ、重複チェック付きスタックを用意して、
デバッグ出力したら、
(0, 0) (1, 3) (2, 1) 0.0 3.81720680758398 [] 0
(2, 1) (0, 2) (0, 0) 3.81720680758398 6.935240796333875 [0] 0
(0, 0) (3, 0) (2, 0) 6.935240796333875 9.435240796333876 [0, 1] 0
(0, 0) (2, 0) (3, 0) 6.935240796333875 8.935240796333876 [0, 1] 1
(2, 1) (0, 0) (0, 2) 3.81720680758398 6.935240796333875 [0] 1
(0, 2) (3, 0) (2, 0) 6.935240796333875 9.73801643406587 [0, 1] 0
(0, 2) (2, 0) (3, 0) 6.935240796333875 9.34945435870697 [0, 1] 1
(2, 1) (3, 0) (2, 0) 3.81720680758398 5.524313588770528 [0] 0
(2, 0) (0, 2) (0, 0) 5.524313588770528 8.938527151143623 [0, 2] 0
(2, 0) (0, 0) (0, 2) 5.524313588770528 8.524313588770529 [0, 2] 1
(2, 1) (2, 0) (3, 0) 3.81720680758398 5.31720680758398 [0] 1

左右と右左の区別は末端しか持っていなくて、スタックは添字のみで、
そこへ方向を入れると、今度は0_0, 1_1のように区別できるが重複チェックは
方向を無視した0, 1で判定する必要があり、訪問フラグとデバッグ用追跡は別なんだな。

# Main_bool_stack
というわけで、デバッグ用にStack<String> stackにしたら、訪問フラグはboolean[] flagでよく、
訪問フラグだけでは深さが分からず、深さを引数に追加する代わりにデバッグ出力しない時も
stack.size()で深さを判定する。

デバッグ出力してみると、これが欲しかったという情報が出た。
(0, 0) (1, 3) (2, 1) 0.0 3.81720680758398 [0_L]
(2, 1) (0, 2) (0, 0) 3.81720680758398 6.935240796333875 [0_L, 1_L]
(0, 0) (3, 0) (2, 0) 6.935240796333875 9.435240796333876 [0_L, 1_L, 2_L]
(0, 0) (2, 0) (3, 0) 6.935240796333875 8.935240796333876 [0_L, 1_L, 2_R]
(2, 1) (0, 0) (0, 2) 3.81720680758398 6.935240796333875 [0_L, 1_R]
(0, 2) (3, 0) (2, 0) 6.935240796333875 9.73801643406587 [0_L, 1_R, 2_L]
(0, 2) (2, 0) (3, 0) 6.935240796333875 9.34945435870697 [0_L, 1_R, 2_R]
(2, 1) (3, 0) (2, 0) 3.81720680758398 5.524313588770528 [0_L, 2_L]
(2, 0) (0, 2) (0, 0) 5.524313588770528 8.938527151143623 [0_L, 2_L, 1_L]
(2, 0) (0, 0) (0, 2) 5.524313588770528 8.524313588770529 [0_L, 2_L, 1_R]
(2, 1) (2, 0) (3, 0) 3.81720680758398 5.31720680758398 [0_L, 2_R]
(3, 0) (0, 2) (0, 0) 5.31720680758398 9.119982445315975 [0_L, 2_R, 1_L]
(3, 0) (0, 0) (0, 2) 5.31720680758398 8.817206807583979 [0_L, 2_R, 1_R]
(0, 0) (2, 1) (1, 3) 0.0 3.3541019662496847 [0_R]
