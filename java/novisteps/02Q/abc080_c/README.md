# Main
nを読み込み、int f[][]に読み込み、int p[][]に読み込む。
ans=LONG\_MINを用意し、iを1からn<1024=2^10までループし、mask = 1、int[] dを用意し、
jを0から10回ループし、(i & mask) > 0の場合、kを0からn回ループし、f[k][j] > 0の場合、d[k]++をカウントする。
mask <<= 1を入れる。
sum = 0を用意し、kを0からn回ループし、sum += p[k][d[k]]を加える。
ansをsumの最大値に更新する。
ansを出力する。
AC 105ms

# Main\_fix
書き直す。

nを読み込み、int af[][]に読み込み、int ap[][]に読み込む。
ans=LONG\_MINを用意し、iを0から2^10回ループし、int[] adを用意し、
jを0から10回ループし、mask=1 << jを入れ、(i&mask)>0の場合、kを0からn回ループし、af[k][j] > 0の場合、ad[k]++をカウントする。
cnt=0、sum=0を用意し、kを0からn回ループし、cnt+=ad[k]、sum+=ap[k][ad[k]]を加える。
cnt>0の場合、ansをsumの最大値に更新する。

ビット探索を0から開始したため、cntが1以上であることを判定に加えている。
AC 139ms

