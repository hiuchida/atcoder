# Main01
事前に3\*10^6の素数を用意する。
tを読み込み、t回ループする。
nを読み込み、素数pを小さい方からループする。
p>n/pとなったら中断する。
pp=(long)p*p、q=n/ppを計算し、pp*q!=nとなったらスキップする。
qが素数でない場合はスキップする。
p,qを出力する。
WA9個。RE10個。

# Main01fix
p,qを出力した後にbreak;をした場合。
WA9個。RE10個。

# Main02
Main01を元に、MAX=3e6+1から1e7に増やす。
WA9個。RE10個。

事前に素数を用意する時間は以下のとおり。
	//1,000,000,000 16678ms
	//  100,000,000  1537ms
	//   10,000,000    98ms
	//    1,000,000    17ms

# Main02fix
p,qを出力した後にbreak;をした場合。
WA9個。RE10個。

# Main03
Main01を元に、n/p*p!=nのときにスキップする。
WA9個。RE10個。

# Main03fix
p,qを出力した後にbreak;をした場合。
WA9個。RE10個。

# Main04
Main01を元に、素数pを小さい方からループしたが、これがp\*pとなるとは限らず、qとなる可能性がある。
porqに変えて、porq>n/porqの場合q=porqとして、もう一方のpを計算する。
WA9個。

# Main04fix
p,qを出力した後にbreak;をした場合。
WA9個。

# Main05
Main04を元に、
n/pp*pp!=nのときに、q=porqとしてもう一方のpを計算する。
WA7個。

# Main
Main05を元に、
q=n/ppのときに、break;忘れ。

Main05の場合、N=63の場合、porq=3のときにp=3からq=7を見つけた場合と、
porq=7のときにq=7からp=3を見つけた場合の2行が出力される。
porq=3のときにbreak;が必要となる。

# Main\_fix
素数のリストをp0として、nがp0で割り切れない場合はスキップ。
nがp0の2乗で割り切れる場合は、p=p0として、qをn/p/pで計算し、p\*p\*qがnと一致することを確認する。
2乗で割り切れない場合は、q=p0として、pをsqrt(n/q)で計算し、p\*p\*qがnと一致することを確認する。

# Main_findByFloyd
試しにfindByFloydを実装したが、(a*a+c)%nがオーバーフローしてそうで怪しい。
BigIntegerではN=1059872604593911が返ってこない。
TLE10個。3312ms。3360380KB。

gcdを再帰呼び出しを止めたら、メモリは軽減した。
TLE10個。3312ms。39920KB。

