# Main
解説の通りに書いていた。
関数電卓で2^20=1,048,576のため、10^6程度で全部探しても大したことない。

正解しているが、ソースを見直すと、
for (int i=0; i<1024*1024; i++) {
なので、常にフルにn=20の組み合わせをループして
for (int j=0; j<20 && j<n; j++) {
で、nで抑えているので、
n=10の場合、i=0～1023で答えが出ているが、1024～1024*1024まで続行して、
下位10ビットが同じパターンを何度も計算している。
おそらく2^nを計算するのが面倒で最大値の定数を使ったが、1<<nでよかった。

細かいところでj<20 && j<nも、n<=20なので、j<nだけよい。
最初に最大の20ビットを想定し、i<1024*1024を書きj<20を書いている。

解説のコードで、こちらはa,bをそれぞれカウントしていたが、全体の合計が分かればa,s-aでよい。
また、aとbの差が最も小さいときの大きい方の最小値を探していたが、
aとbの大きい方の最小値ans=min(ans,max(s,ss-s));でよかった。

# Main_bitshift
ループ条件i<1 << nとj<n。
答えを出すのにans = Math.min(ans, Math.max(a, b));で、ans2は削除。

int mask = 1 << j;は、ループ前にmask = 1;で初期化して、ループ中にmask <<= 1;でも良いが、
int jも必要なのでこれでいいかな。

# Main_dfs
2^nなのでビットを使ったが、dfsで2通り子供を呼び出す。
今度は合計sを事前に計算したので、
dfs(i+1, a+v);
dfs(i+1, a);
を渡すだけでよい。
