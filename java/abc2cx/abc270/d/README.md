# Main01
n,kを読み込み、List<Integer> listに読み込む。
ans=0を用意し、n>0の間ループし、
v=0を用意し、無限ループしv=list.get(list.size()-1)を得て、
n<vの場合listの末尾を取り除き、それ以外は中断する。
ans+=v、n-=vを更新し、n<=0の場合中断する。
無限ループしv=list.get(list.size()-1)を得て、
n<vの場合listの末尾を取り除き、それ以外は中断する。
ループが終了したら、ansを出力する。
WA15個。

# Main02
動的計画法で作り直す。
n,kを読み込み、int[] aryに読み込む。
long[][] dpを用意し、すべて-1で初期化する。
dp[0][0]=0、dp[1][0]=0を入れる。
jを0からn-1までループし、iを0からk-1までループし、a=ary[i]を入れる。
dp[1][j]>=0のとき、j+a<=nの場合dp[0][j+a]にdp[1][j]+aの最大値を更新する。
dp[0][j]>=0のとき、j+a<=nの場合、dp[1][j+a]<0の場合dp[1][j+a]にdp[0][j]をコピーする。
2重ループが終わったら、dp[0][n]を出力する。
WA2個。

# Main03
Main02を元に、Math.max(dp[0][n], dp[1][n])を出力する。
WA2個。

# Main04
Main03を元に、Math.max(Math.max(dp[0][n], dp[1][n]), 0))を出力する。
WA2個。

# Main
Main04を元に、
dp[0]\[\]はすべて-1で初期化し、dp\[1\]\[\]はすべてINT\_MAXで初期化する。
dp[0][j]>=0のとき、j+a<=nの場合、dp[1][j+a]にdp[0][j]の最小値を更新する。
（後から敵に有利な手順が来る場合に、今後の自分が不利になるように更新する）

