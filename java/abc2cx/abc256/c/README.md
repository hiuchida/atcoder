# Main
int[] ah、awに読み込み、ans=0を用意する。
a1,b1を1からah\[0\]までループし、c1=ah[0]-a1-b1を計算し、c1<1ならば中断する。
a2,b2を1からah\[1\]までループし、c2=ah[1]-a2-b2を計算し、c2<1ならば中断する。
a3=aw[0]-a1-a2、b3=aw[1]-b1-b2、c3=aw[2]-c1-c2を計算し、a3,b3,c3<1ならばスキップする。
a3+b3+c3!=ah[2]ならばスキップする。
それ以外はans++する。
4重ループが終了したら、ansを出力する。

# Main\_fix
すべてbreak;にしたら、例3がWAとなる。
5 13 10 6 13 9

そこでa3,b3,c3のチェックをすべてcontinue;に変えたが、
continue;にする必要があるのは1つだけだった。
c3<1について、b2が増加するにつれてc2が減少するため、逆にc3は増加していく。
このため、いまc3<1としても、将来はc3>=1となる可能性があり、break;するとその組み合わせが抜け落ちる。
a3<1は、b2のループは関係ない。
b3<1は、b2が増加すると、b3は減少する。
a3+b3+c3は、c3がaw\[2\]から計算されているため、他のc3はもう存在しない。

						int c2=ah[1]-a2-b2;
						if (c2<1) break;
						int a3=aw[0]-a1-a2;
						if (a3<1) break;
						int b3=aw[1]-b1-b2;
						if (b3<1) break;
						int c3=aw[2]-c1-c2;
						if (c3<1) continue;
						if (a3+b3+c3!=ah[2]) break;
