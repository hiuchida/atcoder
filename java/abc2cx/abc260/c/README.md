# Main
n,x,yを読み込み、long[] red,blueを用意する。
red[n]=1を初期化する。
dfs(n)を呼び出す。
blue[1]を出力する。

dfs内で、i==1で再帰を止める。
red[i]==0 && blue[i]==0ならば、dfs(i-1)を呼び出す。
red[i]>0のとき、red[i-1]+=red[i]、blue[i]+=red[i]*xに分配し、red[i]をクリアし、dfs(i)を呼び出す。
blue[i]>0のとき、red[i-1]+=blue[i]、blue[i-1]+=blue[i]*yに分配し、blue[i]をクリアし、dfs(i)を呼び出す。

# Main\_fix
Mainを元に、dfs内で、red\[i\]>0の直後にblue\[i\]>0の処理を連続して実行してもよい。
すると、red\[i\]>0とblue\[i\]>0の処理の後に、常にdfs(i-1)を呼び出すことになるので、
通常のループで書ける。

iをnから2までループし、red[i-1]+=red[i]、blue[i]+=red[i]*xとred[i-1]+=blue[i]、blue[i-1]+=blue[i]*yを入れる。

r:[0, 871249521, 82779541, 7865086, 747281, 71001, 6746, 641, 61, 6, 1]
b:[0, 3942349900, 788469980, 74914455, 7117805, 676280, 64255, 6105, 580, 55, 5]
3942349900

# Main\_dp
解説の説明の方がよく分からなかったが、レベルの低い方から上げていくと数字が違う。

解説のdpコードのデバッグ出力。
r:[0, 0, 25, 275, 2900, 30525, 321275, 3381400, 35589025, 374572275, 3942349900]
b:[0, 1, 5, 50, 525, 5525, 58150, 612025, 6441525, 67796650, 713555525]
3942349900

