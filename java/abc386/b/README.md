# Main
長さが短いので、'0'が見つかったら、連続する'0'の個数を2重ループで数えている。
前に似たような問題で末尾に番兵がないと、末尾が'0'でj<s.lengthで抜けたときに
ループ後に処理を書かないと行けなかった。

# Main_noGuard
番兵を取ってみたら、i = j-1;が抜けて、スキップしないので重複して'0'を数えてしまう。
結局、ループ後にi = j-1;をするため、jのスコープをfor文内に限定できないので、
ループ前にint j=i;を宣言する。
おそらくこの書き方を嫌う傾向がある。

# Main_noGuard2
もしint j=iをfor文内に入れることにこだわると、j>=s.length()をif文にして後処理してbreak;すればよいが、
今度は2ヵ所になる。
					if (j>=s.length()) {
						i = j-1;
						break;
					}
					if (s.charAt(j) == '0') {
						z++;
					} else {
						i = j-1;
						break;
					}

文字列の長さチェックと'0'を一緒にすればよいが、複雑になると余計に面倒なことになりそう。
					if (j<s.length() && s.charAt(j) == '0') {
						z++;
					} else {
						i = j-1;
						break;
					}

# Main_1loop
2重ループにしてもただ'0'の数を数えたいだけなので、
int z = 0;をループの前に持って行って、'0'以外のときに精算して、
ループの後でz>0のときに精算する。
この方が自然か。
